// SquirrelDB Go SDK - Storage (S3-compatible)
// Generated by sdk-generator v0.1.0
// DO NOT EDIT MANUALLY

package squirreldb

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// StorageOptions for storage client
type StorageOptions struct {
	Endpoint  string
	AccessKey string
	SecretKey string
	Region    string
}

// Storage is an S3-compatible storage client
type Storage struct {
	endpoint  string
	accessKey string
	secretKey string
	region    string
	client    *http.Client
}

// StorageError represents a storage error
type StorageError struct {
	StatusCode int
	Message    string
}

func (e *StorageError) Error() string {
	return fmt.Sprintf("storage error %d: %s", e.StatusCode, e.Message)
}

// ConnectStorage creates a new storage client
func ConnectStorage(opts *StorageOptions) *Storage {
	if opts.Region == "" {
		opts.Region = "us-east-1"
	}
	return &Storage{
		endpoint:  strings.TrimSuffix(opts.Endpoint, "/"),
		accessKey: opts.AccessKey,
		secretKey: opts.SecretKey,
		region:    opts.Region,
		client:    &http.Client{Timeout: 30 * time.Second},
	}
}

func (s *Storage) request(method, path string, body []byte, headers map[string]string) ([]byte, http.Header, error) {
	url := s.endpoint + path
	var bodyReader io.Reader
	if body != nil {
		bodyReader = bytes.NewReader(body)
	}

	req, err := http.NewRequest(method, url, bodyReader)
	if err != nil {
		return nil, nil, err
	}

	if s.accessKey != "" {
		req.Header.Set("x-amz-access-key-id", s.accessKey)
	}
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, nil, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	if resp.StatusCode >= 400 {
		return nil, nil, &StorageError{StatusCode: resp.StatusCode, Message: string(respBody)}
	}

	return respBody, resp.Header, nil
}

// ListBuckets lists all buckets
func (s *Storage) ListBuckets() ([]Bucket, error) {
	body, _, err := s.request("GET", "/", nil, nil)
	if err != nil {
		return nil, err
	}

	re := regexp.MustCompile(`<Name>([^<]+)</Name>`)
	matches := re.FindAllStringSubmatch(string(body), -1)
	buckets := make([]Bucket, len(matches))
	for i, m := range matches {
		buckets[i] = Bucket{Name: m[1], CreatedAt: time.Now().Format(time.RFC3339)}
	}
	return buckets, nil
}

// CreateBucket creates a bucket
func (s *Storage) CreateBucket(name string) error {
	_, _, err := s.request("PUT", "/"+name, nil, nil)
	return err
}

// DeleteBucket deletes a bucket
func (s *Storage) DeleteBucket(name string) error {
	_, _, err := s.request("DELETE", "/"+name, nil, nil)
	return err
}

// BucketExists checks if bucket exists
func (s *Storage) BucketExists(name string) bool {
	_, _, err := s.request("HEAD", "/"+name, nil, nil)
	return err == nil
}

// ListObjects lists objects in bucket
func (s *Storage) ListObjects(bucket string, prefix string, maxKeys int) ([]StorageObject, error) {
	path := "/" + bucket
	params := []string{}
	if prefix != "" {
		params = append(params, "prefix="+prefix)
	}
	if maxKeys > 0 {
		params = append(params, "max-keys="+strconv.Itoa(maxKeys))
	}
	if len(params) > 0 {
		path += "?" + strings.Join(params, "&")
	}

	body, _, err := s.request("GET", path, nil, nil)
	if err != nil {
		return nil, err
	}

	re := regexp.MustCompile(`<Key>([^<]+)</Key>.*?<Size>(\d+)</Size>.*?<ETag>([^<]+)</ETag>`)
	matches := re.FindAllStringSubmatch(string(body), -1)
	objects := make([]StorageObject, len(matches))
	for i, m := range matches {
		size, _ := strconv.ParseInt(m[2], 10, 64)
		objects[i] = StorageObject{
			Key:          m[1],
			Size:         size,
			Etag:         strings.Trim(m[3], `"`),
			LastModified: time.Now().Format(time.RFC3339),
		}
	}
	return objects, nil
}

// GetObject gets object content
func (s *Storage) GetObject(bucket, key string) ([]byte, error) {
	body, _, err := s.request("GET", "/"+bucket+"/"+key, nil, nil)
	return body, err
}

// PutObject uploads object
func (s *Storage) PutObject(bucket, key string, data []byte, contentType string) (string, error) {
	headers := map[string]string{}
	if contentType != "" {
		headers["content-type"] = contentType
	}
	_, respHeaders, err := s.request("PUT", "/"+bucket+"/"+key, data, headers)
	if err != nil {
		return "", err
	}
	return strings.Trim(respHeaders.Get("etag"), `"`), nil
}

// DeleteObject deletes object
func (s *Storage) DeleteObject(bucket, key string) error {
	_, _, err := s.request("DELETE", "/"+bucket+"/"+key, nil, nil)
	return err
}

// ObjectExists checks if object exists
func (s *Storage) ObjectExists(bucket, key string) bool {
	_, _, err := s.request("HEAD", "/"+bucket+"/"+key, nil, nil)
	return err == nil
}
