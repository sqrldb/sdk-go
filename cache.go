// SquirrelDB Go SDK - Cache (Redis-compatible)
// Generated by sdk-generator v0.1.0
// DO NOT EDIT MANUALLY

package squirreldb

import (
	"bufio"
	"errors"
	"fmt"
	"net"
	"strconv"
	"strings"
	"time"
)

// CacheOptions for connecting to cache server
type CacheOptions struct {
	Host string
	Port int
}

// Cache is a Redis-compatible cache client
type Cache struct {
	conn   net.Conn
	reader *bufio.Reader
}

// ConnectCache connects to cache server
func ConnectCache(opts *CacheOptions) (*Cache, error) {
	if opts == nil {
		opts = &CacheOptions{}
	}
	if opts.Host == "" {
		opts.Host = "localhost"
	}
	if opts.Port == 0 {
		opts.Port = 6379
	}

	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", opts.Host, opts.Port), 10*time.Second)
	if err != nil {
		return nil, err
	}

	return &Cache{conn: conn, reader: bufio.NewReader(conn)}, nil
}

// Close the connection
func (c *Cache) Close() error {
	return c.conn.Close()
}

func (c *Cache) command(args ...string) (interface{}, error) {
	cmd := fmt.Sprintf("*%d\r\n", len(args))
	for _, arg := range args {
		cmd += fmt.Sprintf("$%d\r\n%s\r\n", len(arg), arg)
	}
	_, err := c.conn.Write([]byte(cmd))
	if err != nil {
		return nil, err
	}
	return c.readResponse()
}

func (c *Cache) readResponse() (interface{}, error) {
	line, err := c.reader.ReadString('\n')
	if err != nil {
		return nil, err
	}
	line = strings.TrimSuffix(line, "\r\n")

	switch line[0] {
	case '+':
		return line[1:], nil
	case '-':
		return nil, errors.New(line[1:])
	case ':':
		return strconv.ParseInt(line[1:], 10, 64)
	case '$':
		length, _ := strconv.Atoi(line[1:])
		if length == -1 {
			return nil, nil
		}
		data := make([]byte, length+2)
		_, err := c.reader.Read(data)
		if err != nil {
			return nil, err
		}
		return string(data[:length]), nil
	case '*':
		count, _ := strconv.Atoi(line[1:])
		if count == -1 {
			return nil, nil
		}
		arr := make([]interface{}, count)
		for i := 0; i < count; i++ {
			arr[i], err = c.readResponse()
			if err != nil {
				return nil, err
			}
		}
		return arr, nil
	}
	return nil, errors.New("invalid response")
}

// Get a value
func (c *Cache) Get(key string) (string, error) {
	result, err := c.command("GET", key)
	if err != nil || result == nil {
		return "", err
	}
	return result.(string), nil
}

// Set a value
func (c *Cache) Set(key, value string, ttl time.Duration) error {
	if ttl > 0 {
		_, err := c.command("SET", key, value, "EX", strconv.Itoa(int(ttl.Seconds())))
		return err
	}
	_, err := c.command("SET", key, value)
	return err
}

// Del deletes a key
func (c *Cache) Del(key string) (bool, error) {
	result, err := c.command("DEL", key)
	if err != nil {
		return false, err
	}
	return result.(int64) > 0, nil
}

// Exists checks if key exists
func (c *Cache) Exists(key string) (bool, error) {
	result, err := c.command("EXISTS", key)
	if err != nil {
		return false, err
	}
	return result.(int64) > 0, nil
}

// Incr increments value
func (c *Cache) Incr(key string) (int64, error) {
	result, err := c.command("INCR", key)
	if err != nil {
		return 0, err
	}
	return result.(int64), nil
}

// Decr decrements value
func (c *Cache) Decr(key string) (int64, error) {
	result, err := c.command("DECR", key)
	if err != nil {
		return 0, err
	}
	return result.(int64), nil
}

// IncrBy increments by amount
func (c *Cache) IncrBy(key string, amount int64) (int64, error) {
	result, err := c.command("INCRBY", key, strconv.FormatInt(amount, 10))
	if err != nil {
		return 0, err
	}
	return result.(int64), nil
}

// DecrBy decrements by amount
func (c *Cache) DecrBy(key string, amount int64) (int64, error) {
	result, err := c.command("DECRBY", key, strconv.FormatInt(amount, 10))
	if err != nil {
		return 0, err
	}
	return result.(int64), nil
}

// MGet gets multiple values
func (c *Cache) MGet(keys ...string) ([]string, error) {
	args := append([]string{"MGET"}, keys...)
	result, err := c.command(args...)
	if err != nil {
		return nil, err
	}
	arr := result.([]interface{})
	values := make([]string, len(arr))
	for i, v := range arr {
		if v != nil {
			values[i] = v.(string)
		}
	}
	return values, nil
}

// MSet sets multiple values
func (c *Cache) MSet(entries map[string]string) error {
	args := []string{"MSET"}
	for k, v := range entries {
		args = append(args, k, v)
	}
	_, err := c.command(args...)
	return err
}

// Keys finds keys matching pattern
func (c *Cache) Keys(pattern string) ([]string, error) {
	result, err := c.command("KEYS", pattern)
	if err != nil {
		return nil, err
	}
	arr := result.([]interface{})
	keys := make([]string, len(arr))
	for i, v := range arr {
		keys[i] = v.(string)
	}
	return keys, nil
}

// Expire sets key expiration
func (c *Cache) Expire(key string, seconds int) (bool, error) {
	result, err := c.command("EXPIRE", key, strconv.Itoa(seconds))
	if err != nil {
		return false, err
	}
	return result.(int64) > 0, nil
}

// TTL gets key TTL
func (c *Cache) TTL(key string) (int64, error) {
	result, err := c.command("TTL", key)
	if err != nil {
		return 0, err
	}
	return result.(int64), nil
}

// DBSize gets number of keys
func (c *Cache) DBSize() (int64, error) {
	result, err := c.command("DBSIZE")
	if err != nil {
		return 0, err
	}
	return result.(int64), nil
}

// FlushDB deletes all keys
func (c *Cache) FlushDB() error {
	_, err := c.command("FLUSHDB")
	return err
}

// Info gets server info
func (c *Cache) Info() (string, error) {
	result, err := c.command("INFO")
	if err != nil {
		return "", err
	}
	return result.(string), nil
}

// Ping the server
func (c *Cache) Ping() (string, error) {
	result, err := c.command("PING")
	if err != nil {
		return "", err
	}
	return result.(string), nil
}
