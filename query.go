// SquirrelDB Go SDK - Query Builder
// Generated by sdk-generator v0.1.0
// DO NOT EDIT MANUALLY

package squirreldb

import (
	"encoding/json"
)

// SortDirection represents sort order
type SortDirection string

const (
	SortAsc  SortDirection = "asc"
	SortDesc SortDirection = "desc"
)

// FilterCondition represents a single filter condition
type FilterCondition struct {
	Field    string      `json:"field"`
	Operator string      `json:"operator"`
	Value    interface{} `json:"value"`
}

// SortSpec represents a sort specification
type SortSpec struct {
	Field     string        `json:"field"`
	Direction SortDirection `json:"direction"`
}

// ChangesOptions represents options for change subscriptions
type ChangesOptions struct {
	IncludeInitial bool `json:"includeInitial"`
}

// StructuredQuery represents the wire format query
type StructuredQuery struct {
	Table   string                            `json:"table"`
	Filter  map[string]map[string]interface{} `json:"filter,omitempty"`
	Sort    []SortSpec                        `json:"sort,omitempty"`
	Limit   *int                              `json:"limit,omitempty"`
	Skip    *int                              `json:"skip,omitempty"`
	Changes *ChangesOptions                   `json:"changes,omitempty"`
}

// FieldExpr represents a field expression for building filter conditions
type FieldExpr struct {
	fieldName string
}

// Field creates a new field expression
func Field(name string) *FieldExpr {
	return &FieldExpr{fieldName: name}
}

// Eq creates an equal condition
func (f *FieldExpr) Eq(value interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$eq", Value: value}
}

// Ne creates a not equal condition
func (f *FieldExpr) Ne(value interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$ne", Value: value}
}

// Gt creates a greater than condition
func (f *FieldExpr) Gt(value interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$gt", Value: value}
}

// Gte creates a greater than or equal condition
func (f *FieldExpr) Gte(value interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$gte", Value: value}
}

// Lt creates a less than condition
func (f *FieldExpr) Lt(value interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$lt", Value: value}
}

// Lte creates a less than or equal condition
func (f *FieldExpr) Lte(value interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$lte", Value: value}
}

// In creates a value in array condition
func (f *FieldExpr) In(values ...interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$in", Value: values}
}

// NotIn creates a value not in array condition
func (f *FieldExpr) NotIn(values ...interface{}) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$nin", Value: values}
}

// Contains creates a string contains condition
func (f *FieldExpr) Contains(value string) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$contains", Value: value}
}

// StartsWith creates a string starts with condition
func (f *FieldExpr) StartsWith(value string) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$startsWith", Value: value}
}

// EndsWith creates a string ends with condition
func (f *FieldExpr) EndsWith(value string) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$endsWith", Value: value}
}

// Exists creates a field exists condition
func (f *FieldExpr) Exists(value bool) FilterCondition {
	return FilterCondition{Field: f.fieldName, Operator: "$exists", Value: value}
}

// QueryBuilder builds SquirrelDB queries
type QueryBuilder struct {
	tableName   string
	filters     []FilterCondition
	sorts       []SortSpec
	limitValue  *int
	skipValue   *int
	changesOpts *ChangesOptions
}

// Table creates a new query builder for a table
func Table(name string) *QueryBuilder {
	return &QueryBuilder{
		tableName: name,
		filters:   make([]FilterCondition, 0),
		sorts:     make([]SortSpec, 0),
	}
}

// Find adds filter conditions
func (q *QueryBuilder) Find(conditions ...FilterCondition) *QueryBuilder {
	q.filters = append(q.filters, conditions...)
	return q
}

// Sort adds a sort specification
func (q *QueryBuilder) Sort(fieldName string, direction SortDirection) *QueryBuilder {
	q.sorts = append(q.sorts, SortSpec{Field: fieldName, Direction: direction})
	return q
}

// Limit sets maximum number of results
func (q *QueryBuilder) Limit(n int) *QueryBuilder {
	q.limitValue = &n
	return q
}

// Skip sets number of results to skip
func (q *QueryBuilder) Skip(n int) *QueryBuilder {
	q.skipValue = &n
	return q
}

// Changes subscribes to changes
func (q *QueryBuilder) Changes(opts *ChangesOptions) *QueryBuilder {
	if opts == nil {
		q.changesOpts = &ChangesOptions{IncludeInitial: true}
	} else {
		q.changesOpts = opts
	}
	return q
}

// CompileStructured returns the structured query object
func (q *QueryBuilder) CompileStructured() StructuredQuery {
	query := StructuredQuery{
		Table: q.tableName,
	}

	if len(q.filters) > 0 {
		query.Filter = q.buildFilterObject()
	}

	if len(q.sorts) > 0 {
		query.Sort = q.sorts
	}

	if q.limitValue != nil {
		query.Limit = q.limitValue
	}

	if q.skipValue != nil {
		query.Skip = q.skipValue
	}

	if q.changesOpts != nil {
		query.Changes = q.changesOpts
	}

	return query
}

// Compile returns the query as a JSON string
func (q *QueryBuilder) Compile() (string, error) {
	data, err := json.Marshal(q.CompileStructured())
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (q *QueryBuilder) buildFilterObject() map[string]map[string]interface{} {
	filterObj := make(map[string]map[string]interface{})
	for _, cond := range q.filters {
		if _, ok := filterObj[cond.Field]; !ok {
			filterObj[cond.Field] = make(map[string]interface{})
		}
		filterObj[cond.Field][cond.Operator] = cond.Value
	}
	return filterObj
}

// And combines conditions with AND
func And(conditions ...FilterCondition) FilterCondition {
	return FilterCondition{
		Field:    "$and",
		Operator: "$and",
		Value:    conditions,
	}
}

// Or combines conditions with OR
func Or(conditions ...FilterCondition) FilterCondition {
	return FilterCondition{
		Field:    "$or",
		Operator: "$or",
		Value:    conditions,
	}
}

// Not negates a condition
func Not(condition FilterCondition) FilterCondition {
	return FilterCondition{
		Field:    "$not",
		Operator: "$not",
		Value:    condition,
	}
}
