// SquirrelDB Go SDK - Client
// Generated by sdk-generator v0.1.0
// DO NOT EDIT MANUALLY

package squirreldb

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"sync"
	"sync/atomic"

	"github.com/gorilla/websocket"
)

var (
	ErrNotConnected    = errors.New("not connected")
	ErrClosed          = errors.New("connection closed")
	ErrVersionMismatch = errors.New("protocol version mismatch")
	ErrAuthFailed      = errors.New("authentication failed")
)

// Options for connecting to SquirrelDB
type Options struct {
	Host      string
	Port      int
	AuthToken string
}

// Client is a SquirrelDB WebSocket client
type Client struct {
	conn          *websocket.Conn
	pending       sync.Map
	subscriptions sync.Map
	requestID     atomic.Int64
	closed        atomic.Bool
	mu            sync.Mutex
}

type pendingRequest struct {
	ch  chan json.RawMessage
	err chan error
}

// Connect to SquirrelDB server
func Connect(ctx context.Context, opts *Options) (*Client, error) {
	if opts == nil {
		opts = &Options{Host: "localhost", Port: 8080}
	}
	if opts.Host == "" {
		opts.Host = "localhost"
	}
	if opts.Port == 0 {
		opts.Port = 8080
	}

	u := url.URL{Scheme: "ws", Host: fmt.Sprintf("%s:%d", opts.Host, opts.Port)}
	conn, _, err := websocket.DefaultDialer.DialContext(ctx, u.String(), nil)
	if err != nil {
		return nil, err
	}

	client := &Client{conn: conn}
	go client.listen()
	return client, nil
}

func (c *Client) listen() {
	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			c.closed.Store(true)
			return
		}

		var msg map[string]json.RawMessage
		if err := json.Unmarshal(message, &msg); err != nil {
			continue
		}

		var msgType string
		json.Unmarshal(msg["type"], &msgType)

		switch msgType {
		case "Result", "Error", "Subscribed", "Unsubscribed", "Collections":
			var id string
			json.Unmarshal(msg["id"], &id)
			if v, ok := c.pending.LoadAndDelete(id); ok {
				req := v.(*pendingRequest)
				if msgType == "Error" {
					var errMsg string
					json.Unmarshal(msg["message"], &errMsg)
					req.err <- errors.New(errMsg)
				} else {
					req.ch <- message
				}
			}
		case "Change":
			var subID string
			json.Unmarshal(msg["subscription_id"], &subID)
			if v, ok := c.subscriptions.Load(subID); ok {
				cb := v.(func(ChangeEvent))
				var change ChangeEvent
				json.Unmarshal(msg["change"], &change)
				cb(change)
			}
		}
	}
}

func (c *Client) send(ctx context.Context, msg map[string]interface{}) (json.RawMessage, error) {
	if c.closed.Load() {
		return nil, ErrClosed
	}

	id := fmt.Sprintf("req-%d", c.requestID.Add(1))
	msg["id"] = id

	req := &pendingRequest{ch: make(chan json.RawMessage, 1), err: make(chan error, 1)}
	c.pending.Store(id, req)
	defer c.pending.Delete(id)

	data, _ := json.Marshal(msg)
	c.mu.Lock()
	err := c.conn.WriteMessage(websocket.TextMessage, data)
	c.mu.Unlock()
	if err != nil {
		return nil, err
	}

	select {
	case result := <-req.ch:
		return result, nil
	case err := <-req.err:
		return nil, err
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// Close the connection
func (c *Client) Close() error {
	c.closed.Store(true)
	return c.conn.Close()
}

// Ping the server
func (c *Client) Ping(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.conn.WriteMessage(websocket.TextMessage, []byte(`{"type":"Ping"}`))
}

// ListCollections returns all collections
func (c *Client) ListCollections(ctx context.Context) ([]string, error) {
	result, err := c.send(ctx, map[string]interface{}{"type": "ListCollections"})
	if err != nil {
		return nil, err
	}
	var resp struct{ Collections []string }
	json.Unmarshal(result, &resp)
	return resp.Collections, nil
}

// Query executes a query
func (c *Client) Query(ctx context.Context, query string) ([]Document, error) {
	result, err := c.send(ctx, map[string]interface{}{"type": "Query", "query": query})
	if err != nil {
		return nil, err
	}
	var resp struct{ Documents []Document }
	json.Unmarshal(result, &resp)
	return resp.Documents, nil
}

// Insert a document
func (c *Client) Insert(ctx context.Context, collection string, data map[string]interface{}) (*Document, error) {
	result, err := c.send(ctx, map[string]interface{}{
		"type":       "Insert",
		"collection": collection,
		"data":       data,
	})
	if err != nil {
		return nil, err
	}
	var resp struct{ Documents []Document }
	json.Unmarshal(result, &resp)
	if len(resp.Documents) > 0 {
		return &resp.Documents[0], nil
	}
	return nil, nil
}

// Update a document
func (c *Client) Update(ctx context.Context, collection, id string, data map[string]interface{}) (*Document, error) {
	result, err := c.send(ctx, map[string]interface{}{
		"type":        "Update",
		"collection":  collection,
		"document_id": id,
		"data":        data,
	})
	if err != nil {
		return nil, err
	}
	var resp struct{ Documents []Document }
	json.Unmarshal(result, &resp)
	if len(resp.Documents) > 0 {
		return &resp.Documents[0], nil
	}
	return nil, nil
}

// Delete a document
func (c *Client) Delete(ctx context.Context, collection, id string) (*Document, error) {
	result, err := c.send(ctx, map[string]interface{}{
		"type":        "Delete",
		"collection":  collection,
		"document_id": id,
	})
	if err != nil {
		return nil, err
	}
	var resp struct{ Documents []Document }
	json.Unmarshal(result, &resp)
	if len(resp.Documents) > 0 {
		return &resp.Documents[0], nil
	}
	return nil, nil
}

// Subscribe to changes
func (c *Client) Subscribe(ctx context.Context, query string, callback func(ChangeEvent)) (string, error) {
	result, err := c.send(ctx, map[string]interface{}{"type": "Subscribe", "query": query})
	if err != nil {
		return "", err
	}
	var resp struct{ SubscriptionID string `json:"subscription_id"` }
	json.Unmarshal(result, &resp)
	c.subscriptions.Store(resp.SubscriptionID, callback)
	return resp.SubscriptionID, nil
}

// Unsubscribe from changes
func (c *Client) Unsubscribe(ctx context.Context, subscriptionID string) error {
	_, err := c.send(ctx, map[string]interface{}{
		"type":            "Unsubscribe",
		"subscription_id": subscriptionID,
	})
	c.subscriptions.Delete(subscriptionID)
	return err
}
